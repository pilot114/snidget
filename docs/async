Асинхронность в PHP: минимальный практический пример

> Предпосылки

Для начала нужно понять конечную цель - зачем вообще нужна асинхронность, что она нам даёт?
Даёт она очень простую вещь - возможность не простаивать в ожидании окончания медленных операций
(как показательные примеры: сетевые запросы, обращения к файловой системе), а делать что-то полезное.
Другими словами, аcинхронность полезна в условиях большого количества операций ввода/вывода при высоких
требованиях по утилизации CPU.

Сейчас эта проблема нивелируется на архитектурном уровне, а именно запуском php в виде модуля
к стороннему http-серверу в режиме менеджера процессов. Процессы независимы, один процесс не может
замедлить выполнение другого или как-то напрямую нарушить его работу. Также приятным бонусом дается
"бесплатная" паралельность - процессы могут быть раскиданы системой на разные ядра процессора.

Это простое решение, оно работает вполне приемлемо, однако в рамках каждого отдельного процесса
мы все равно ждём. Безполезные накладные расходы на переключение между процессами и отстутсвие
возможности организации [кооперативной многозадачности] в совокупности дают ряд ограничений,
которые не позволяют писать на PHP полноценные приложения реального времени.

> А что мешает?

В техническом смысле - ничего. Мешает только непонимание как собственно начать писать такой код.
Чтож, давайте разбираться. К концу этой статьи у нас будет полностью работоспособный пример кода для организации
кооперативной многозадачности с event-loop, таймерами, асинхронностью и т.д.

Чтобы в очередной раз не разжевывать все термины - вот ссылки на статьи по теме:
[...]

> пишем шедулер

Итак, представим что у нас есть задача сходить по сети, посчитать что-то на основе
полученных данных и записать результат на диск, очень такой типичный набор действий.
Для удобства, запишем в результат работы также временные отметки наших действий.

$data = file_get_contents('');
$prepared = prepare($data);
file_put_contents(data, 'name');
echo 'done';

Так как каждый следующий этап является результатом работы предыдущего, возникает мысль
что ничего ускорить нельзя чисто логически. Однако, тут прилетает требование
"а давайте скачивать не 1 ресурс, а произвольное кол-во, а еще
бы в реальном времени прогресс видеть. А еще бы отменять что подвисло..."

Для начала пробуем допилить существующий код:

function job() {
    $data = file_get_contents('');
    $prepared = prepare($data);
    file_put_contents(data, 'name');
}

$urls = [];
foreach($urls as $url) {
    job($url);
}


> в чем отличия от синхронного кода
внутри и снаружи, дебаг, сервер и крон
> бонус
несколько ядер и замеры
